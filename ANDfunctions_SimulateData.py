"""
Functions used to simulate data for the Avian Nutrient Distributions Project

Assumptions:
    -body and tissue masses are randomly normally distributed using house 
    finch data from fall 2017; currently, these are independent of each other
    -total carotenoid concentration for each tissue is randomly normally 
    distributed using house finch data from fall 2017
    -carotenoid type concentration is determined by multiplying the total 
    carotenoid concentration for each tissue by a pre-set modifier that can 
    change based on the settings of the input parameters
        -if constantcp is True, then all proportions are as follows
            2/3 lutein, 1/3 zeaxanthin
        -if constantcp is False, then B group proportions are as follows
            1/3 lutein, 2/3 zeaxanthin
    -all same sex (male)
    -mass sample and mass total are the same for all tissues
    -simplest carotenoid profile (lutein and zeaxanthin only) with differences
    only in total amount by tissue or proportion of lutein vs. zeaxanthin and 
    all tissues except tidiff are plasma-like (2/3 lutein, 1/3 zeaxanthin)
    -while more than two groups can be generated, this code can only compare 
    two groups functionally (because there is only one alternative difference 
    that can be set at a time and it is such that A is the control group and 
    B is the treatment group)
    -for now, tissue types are limited to brain, liver, spleen, lung, kidney, 
    heart, and muscle but any of these tissues could be designated as tidiff 
    (i.e. different either in total or proportion of carotenoids or both)
    -for now, if you have more than one tissue that is different, there is not 
    a way to make different tissues vary in different ways (e.g. liver has 
    different proportions and more total carotenoid concentration but spleen 
    has constant proportions but more total carotenoid concentration)


What is the best method for generating variation in carotenoid types?
I could use carotenoid concentrations from real data (mu and sigma) then get 
the amount by multiplying by randomly generated tissue masses.
I could randomize amount and tissue mass separately and calculate concentraion 
from that. 
How are these two methods different? What effect would using either have on the data?
That decision rests on whether I think carotenoid allocation is driven by amount 
independent of tissue mass or concentration (dependent on tissue mass).
I think carotenoid allocation is tissue mass dependent, so I'm going to go with that.
Is there a way of testing that? I think there is, and I think it would be true.
But I should test it anyway if I want this to be truly based on real data.

How do you determine an estimate for "true" variance to use for sigma?
Meaning, what sigma should I use to avoid including variance due to sample size.

Add code to prevent negative numbers from being generated by the np.random.normal functions.
"""

# imports
import numpy as np
import ANDclasses as c

# global variable for group letters
alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", 
            "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

# global variable for possible nutrient types
possnutri = ["lutein", "zeaxanthin"]

# global variable for tissue mass mu, sigma
# based on fall 2017 male house finches
tissue_masses = {"brain" : (0.78,0.07), 
                 "heart" : (0.27,0.03), 
                 "kidney" : (0.13,0.02), 
                 "liver" : (0.45,0.1), 
                 "lung" : (0.24, 0.04), 
                 "muscle" : (3.01,0.4), 
                 "spleen" : (0.017,0.009)}

# global variable for total carot conc mu, sigma
# based on fall 2017 male house finches
total_carot_conc = {"brain" : (0.99, 0.44), 
                    "heart" : (27.13, 8.24),
                    "kidney" : (26.42, 3.05), 
                    "liver" : (57.06, 25.35), 
                    "lung" : (32.70, 6.30), 
                    "muscle" : (7.17, 1.68), 
                    "spleen" : (47.04, 8.40)}


def simBIRD(parainput):
    """ 
    Makes dictionary with key=birdid and value=BIRD object
    
    because this method creates an empty list and fills it later with a tissue 
    obj, in order to print an obj (for debugging purposes), you need to add a 
    [0] to the end to indicate that it is the first (and only) item in the list
    e.g. bird["A1"].tissues["liver"][0]
    """
    totalbird = parainput["ngroup"] * parainput["nbird"]  
    # generate list of unique numbers for each birdid
    birdnumbers = []
    for n in range(totalbird):
        birdnumbers.append(str(n + 1))
    # generate list of group letters for each birdid
    birdletters = []
    for g in range(parainput["ngroup"]):
        for nb in range(parainput["nbird"]):
            birdletters.append(alphabet[g])
    # merge letters and numbers to form birdids!
    birdids = [i + j for i, j in zip(birdletters, birdnumbers)]
    # generate sex data for BIRD init
    sex = ["Male"] * totalbird
    # generate treatment group data for BIRD init (same as birdletters)
    treatment = birdletters
    # generate tissue dictionaries with keys corresponding to tissue names
    # based on parameter inputs and empty values to be filled in later
    bird_tissue_dicts = {} # fill with key = birdid, value = tissue dict
    # iterate through birdids and add same tissue dict to each one
    # tissue dict contains key = tissue names, value = empty 
    for b in birdids:
        key1 = b
        value1 = {} # empty tissues dict
        for t in parainput["whichti"]:
            key2 = t
            value1.setdefault(key2, [])
        bird_tissue_dicts[key1] = value1
    # generate body mass data for BIRD init
    # using average (18.5) and stdev (1.6) of fall 2017 house finches
    mu, sigma = 18.5, 1.6
    bodymass = np.random.normal(mu, sigma, totalbird).round(2)
    i = 0
    bird = {}
    for b in birdids:
        bird[b] = c.BIRD(i = b, s = sex[i], tr = treatment[i], bm = bodymass[i], ti = bird_tissue_dicts[b])
        i += 1
    return bird
    # right now this dictinary of bird objects contain id, sex, treatment, bodymass, 
    # and dictionaries of tissue types with empty values


def simTISSUE(bird):
    """
    Adds TISSUE objects to bird dictionary and adds carot_conc_ind (dictionary 
    with key = tissue type, value = nutrients (dictionary with key = nutrient 
    type, value = empty list)) to existing BIRD objects
    """
    carot_conc_ind = {}
    for bird_id, bird_obj in bird.items():
        for tissue_type, empty_list in bird_obj.tissues.items():
            nutrients = {}
            for nutrient_type in possnutri:
                nutrients[nutrient_type] = []
            mass_total = simMass(tissue_type)
            mass_sample = mass_total
            tissue_obj = c.TISSUE(n = tissue_type, ms = mass_sample, mt = mass_total, b = bird_id)
            bird_obj.tissues[tissue_type].append(tissue_obj)
            carot_conc_ind[tissue_type] = nutrients
        setattr(bird_obj, "carot_conc_ind", carot_conc_ind)


def simNutrients(bird, parainput):
    """
    Generates concentrations for each carotenoid type in each tissue type 
    based on preset means and variances as well as user input.
    
    Check assumption that all nutrients within tissue types are normally 
    distributed.
    
    Right now, the way that carot_conc is appended to carot_conc_ind, it is 
    adding as many values as there are total birds and each of the values 
    within a tissue-and-nutrient type combination are different, but the values 
    are the same among tissue-and-nutrient type combinations. Ideally, there 
    would only be one value produced that is unique for every tissue-and-
    nutrient type combination; however, the solution I am currently using is 
    to keep track of the index number by bird in the getSimCol function of the 
    ANDfunctions_GetOutput.py file and only include one of the values 
    (according to bird id) per bird. All of the numbers within one of these 
    sets is at least tissue and nutrient type specific, but they would repeat 
    between individual birds if only the first value was selected.
    """
    for bird_id, bird_obj in bird.items():
        treatment = bird_obj.treatment
        for tissue_type, nutrients in bird_obj.carot_conc_ind.items():
            for nutrient_type, empty_list in nutrients.items():
                mu, sigma, mod_np, mod_ms = chooseMods(nt = nutrient_type, tt = tissue_type, tr = treatment, parainput = parainput)
                carot_conc = np.random.normal(mu, sigma) * mod_np * mod_ms
                bird_obj.carot_conc_ind[tissue_type][nutrient_type].append(carot_conc)


def chooseMods(nt, tt, tr, parainput):
    """
    Checks user inputs (parainput) and sets the modifiers for carotenoid type 
    proportions and total carotenoid concentrations. Also sets the mean and 
    variance values based on presets for a given tissue type.
    
    May need to generalize code later for more than two groups if needed. If
    so, I could use a random choice function to select group that differs.
    e.g. diff = rand.choice("A", "B")
    """    
    # mod_np = nutrient proportion modifier (e.g. 2/3 for lutein in group "A")
    # mod_ms = mu, sigma modifier (e.g. 1.5 for 50% increase in total carotenoids)
    
    # if the current tissue is different between groups AND 
    # this bird is not a control bird, then...
    if (tt in parainput["tidiff"]) and (tr == "B"):
        if parainput["constanttc"] == True:
            mod_ms = 1
            if parainput["constantcp"] == True:
                if nt == "lutein":
                    mod_np = 2/3
                elif nt == "zeaxanthin":
                    mod_np = 1/3
                else:
                    pass
            elif parainput["constantcp"] == False:
                if nt == "lutein":
                    mod_np = 1/3
                elif nt == "zeaxanthin":
                    mod_np = 2/3
                else:
                    pass
        elif parainput["constanttc"] == False:
            mod_ms = 1.5
            if parainput["constantcp"] == True:
                if nt == "lutein":
                    mod_np = 2/3
                elif nt == "zeaxanthin":
                    mod_np = 1/3
                else:
                    pass
            elif parainput["constantcp"] == False:
                if nt == "lutein":
                    mod_np = 1/3
                elif nt == "zeaxanthin":
                    mod_np = 2/3
                else:
                    pass     
        else:
                print("error")
    # otherwise (if tissue is not different or it is but this is a control bird)...
    else:
        mod_ms = 1
        if nt == "lutein":
            mod_np = 2/3
        elif nt == "zeaxanthin":
            mod_np = 1/3
        else:
            pass
    for tissue_type, tissue_carot in total_carot_conc.items():
        if tt == tissue_type:
            mu, sigma = tissue_carot
        else:
            pass    
    return mu, sigma, mod_np, mod_ms


def simMass(tt):
    """
    Generates tissue masses 
    """
    for tissue_type, tissue_mass in tissue_masses.items(): 
        # if the tissue type matches one of the tissues in the list...
        if tt == tissue_type:
            mu, sigma = tissue_mass
            mass_total = np.random.normal(mu, sigma)
            return mass_total
        # do not do anything if there is a tissue that does not match
        else:
            pass
        

### test code zone ###

#import ANDfunctions_StoreData as sd
#import ANDfunctions_GetOutput as go

#np.random.seed()
#headers = ""
#my_file, outfile_name, alt_calc, list_except = sd.getInput()
#parainput = sd.readSimInputs(my_file)
#bird = simBIRD(parainput)
#simTISSUE(bird)
#simNutrients(bird, parainput)
#simTISSUE(bird, parainput)
#cols = go.getSimCol(bird)
#list_rows = go.colToRow(cols)
#go.writeOutput(outfile_name, list_rows, headers)



#nt = "lutein"
#tt = "liver"
#tr = "B"
#mu, sigma, mod_np, mod_ms = chooseMods(nt, tt, tr, parainput)
#x = np.random.normal(mu, sigma, 15) * mod_np * mod_ms
#print(nt + " " + tt + " " + tr)
#print("mod np" + str(mod_np))
#print("mod ms" + str(mod_ms))
#for i in x:
#    print(i)




